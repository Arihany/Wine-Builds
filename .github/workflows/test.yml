name: Build Proton-base Wine (ARM64EC, WoW64) â€” elegant & pinned

on:
  workflow_dispatch:
    inputs:
      wine_tag:
        description: 'ValveSoftware/wine tag (e.g. proton-wine-10.0-2d)'
        required: true
        default: 'proton-wine-10.0-2d'
      toolchain_url:
        description: 'Override URL for llvm-mingw toolchain asset (Linux/Ubuntu tar.*). If empty, auto-select (prefers bylaws ubuntu-20.04 x86_64).'
        required: false
        default: ''

permissions:
  contents: read
  actions: read

concurrency:
  group: wine-${{ github.ref }}-${{ inputs.wine_tag }}
  cancel-in-progress: true

defaults:
  run:
    shell: 'bash --noprofile --norc -Eeuo pipefail {0}'

jobs:
  build:
    runs-on: ubuntu-24.04
    env:
      PREFIX: ${{ github.workspace }}/_inst
      STAGE:  ${{ github.workspace }}/_stage
      TOOLCHAIN_ROOT: ${{ github.workspace }}/.toolchains
      LLVM_TC_DIR: ${{ github.workspace }}/.toolchains/llvm-mingw-arm64ec
      CCACHE_DIR: ${{ github.workspace }}/.ccache
      CCACHE_MAXSIZE: 4G
      CCACHE_COMPRESS: '1'

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Prepare dirs
        run: mkdir -p "$TOOLCHAIN_ROOT" "$CCACHE_DIR"

      - name: Query llvm-mingw meta (prefer bylaws ubuntu-20.04 x86_64)
        id: tcmeta
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -Eeuo pipefail
          # 0) Manual override
          override_url='${{ inputs.toolchain_url }}'
          if [[ -n "$override_url" ]]; then
            echo 'tag=override' >> "$GITHUB_OUTPUT"
            echo "url=$override_url" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # host arch pattern for generic fallback
          host=$(uname -m)
          case "$host" in
            x86_64|amd64) host_pat='(x86_64|amd64|x64)';;
            aarch64|arm64) host_pat='(aarch64|arm64)';;
            *) echo "Unsupported host arch: $host" >&2; exit 1;;
          esac

          per_page=25
          api="https://api.github.com/repos/bylaws/llvm-mingw/releases?per_page=${per_page}"
          tmp_json=$(mktemp)
          http=$(curl -fsS -H "Authorization: Bearer ${GH_TOKEN}" -H 'Accept: application/vnd.github+json' -o "$tmp_json" -w '%{http_code}' "$api")
          if [[ "$http" != 200 ]]; then
            echo "::error title=GitHub API error::HTTP $http from $api"; sed -n '1,120p' "$tmp_json" || true; exit 1
          fi

          jq_first_ubuntu2004=$(mktemp)
          cat >"$jq_first_ubuntu2004" <<'JQ'
            .[] | .tag_name as $tag | .assets[]? | select(
              (.name | test("(?i)llvm-mingw-.*-ubuntu-20[.]04-x86_64[.]tar[.](xz|zst|gz)$"))
            ) | [$tag, .browser_download_url] | @tsv
          JQ

          jq_generic=$(mktemp)
          cat >"$jq_generic" <<'JQ'
            .[] | .tag_name as $tag | .assets[]? | select(
              (.name | test("(?i)llvm-mingw-.*-(ubuntu|linux)-")) and
              (.name | test(env.HOST_PAT)) and
              (.name | test("[.]tar[.](xz|zst|gz)$"))
            ) | [$tag, .browser_download_url] | @tsv
          JQ

          HOST_PAT="$host_pat" jq -r -f "$jq_first_ubuntu2004" "$tmp_json" | head -n1 > match.txt || true
          if [[ ! -s match.txt ]]; then
            HOST_PAT="$host_pat" jq -r -f "$jq_generic" "$tmp_json" | head -n1 > match.txt || true
          fi
          if [[ ! -s match.txt ]]; then
            echo "::error title=No matching llvm-mingw Linux asset::Searched last ${per_page} releases; host=$host (${host_pat})"
            jq -r '.[0].assets[]?.name' "$tmp_json" | head -n20 || true
            exit 1
          fi

          tag=$(cut -f1 match.txt)
          url=$(cut -f2 match.txt)
          echo "tag=$tag" >> "$GITHUB_OUTPUT"
          echo "url=$url" >> "$GITHUB_OUTPUT"

      - name: Cache toolchain (extracted)
        id: cache_tc
        uses: actions/cache@v4
        with:
          path: ${{ env.LLVM_TC_DIR }}
          key: llvm-mingw-arm64ec-${{ runner.os }}-${{ steps.tcmeta.outputs.tag }}

      - name: Download & extract toolchain if cache missed
        if: steps.cache_tc.outputs.cache-hit != 'true'
        run: |
          set -Eeuo pipefail
          mkdir -p "$LLVM_TC_DIR"
          cd "$TOOLCHAIN_ROOT"
          file=$(basename "${{ steps.tcmeta.outputs.url }}")
          echo "Downloading: $file"
          curl -fL --retry 5 --retry-delay 3 -o "$file" "${{ steps.tcmeta.outputs.url }}"
          case "$file" in
            *.tar.xz)  tar -C "$LLVM_TC_DIR" --strip-components=1 -xf "$file" ;;
            *.tar.zst) tar --zstd -C "$LLVM_TC_DIR" --strip-components=1 -xf "$file" ;;
            *.tar.gz)  tar -C "$LLVM_TC_DIR" --strip-components=1 -xzf "$file" ;;
            *) echo "Unknown archive format: $file" >&2; exit 1 ;;
          esac

      - name: Add toolchain to PATH (prepend)
        run: echo "PATH=${{ env.LLVM_TC_DIR }}/bin:$PATH" >> $GITHUB_ENV

      - name: Sanity probe clang path and arm64ec target
        shell: bash
        run: |
          set -Eeuo pipefail
          echo ::group::shell
          echo "SHELL=${SHELL:-}"
          echo "BASH_VERSION=${BASH_VERSION:-n/a}"
          ps -p $$ -o comm=
          echo ::endgroup::

          echo ::group::clang
          which clang || true
          clang --version || true
          echo ::endgroup::

          echo ::group::arm64ec-probe
          set +e
          printf 'int main(void){return 0;}' > t.c
          clang -target arm64ec-windows -fuse-ld=lld -Wl,-subsystem:console -Wl,-WX -v t.c -o t.exe
          stat t.exe || true
          rm -f t.c t.exe || true
          echo ::endgroup::

          echo ::group::arm64ec-probe
          set +e
          printf 'int main(void){return 0;}' > t.c
          clang -target arm64ec-windows -fuse-ld=lld -Wl,-subsystem:console -Wl,-WX -v t.c -o t.exe
          stat t.exe || true
          rm -f t.c t.exe || true
          echo ::endgroup::

      - name: Verify ARM64EC toolchain presence (fail-fast)
        shell: bash
        run: |
          set -Eeuo pipefail
          need="arm64ec-w64-mingw32-clang arm64ec-w64-mingw32-clang++ aarch64-w64-mingw32-clang i686-w64-mingw32-clang llvm-dlltool llvm-windres lld-link"
          ok=1
          for b in $need; do
            if ! command -v "$b" >/dev/null 2>&1; then echo "::error title=Missing::$b not found"; ok=0; else which "$b"; "$b" --version | head -n1 || true; fi
          done
          if [[ $ok -ne 1 ]]; then
            echo "::error title=ARM64EC toolchain incomplete::Provide toolchain_url for a working build"; exit 1
          fi

      - name: Cache ccache
        uses: actions/cache@v4
        with:
          path: ${{ env.CCACHE_DIR }}
          key: ccache-${{ runner.os }}-${{ inputs.wine_tag }}-${{ steps.tcmeta.outputs.tag }}-v1
          restore-keys: |
            ccache-${{ runner.os }}-

      - name: Install build deps (incl. Debian Wine control.in hints)
        run: |
          set -Eeuo pipefail
          sudo apt-get update -y -o Acquire::Retries=3
          sudo apt-get install -y --no-install-recommends \
            build-essential clang lld git curl jq xz-utils zstd rsync pkg-config \
            bison flex gettext autoconf automake libtool \
            libfreetype6-dev libfontconfig1-dev libglib2.0-dev libunwind-dev \
            libx11-dev libxext-dev libxi-dev libxrandr-dev libxrender-dev \
            libxcursor-dev libxfixes-dev libxinerama-dev libxcomposite-dev \
            libxdamage-dev libxkbcommon-dev libwayland-dev libdbus-1-dev \
            libasound2-dev libpulse-dev libudev-dev libvulkan-dev libopengl-dev \
            ocl-icd-opencl-dev zlib1g-dev libjpeg-dev libpng-dev libtiff-dev \
            libgsm1-dev libldap2-dev libpcap0.8-dev ccache \
            libgnutls28-dev liblcms2-dev libkrb5-dev libcups2-dev \
            libgphoto2-dev libsane-dev libmpg123-dev libsdl2-dev libopenal-dev \
            libosmesa6-dev libvkd3d-dev libgstreamer-plugins-base1.0-dev \
            libgstreamer1.0-dev libcapi20-dev libxslt1-dev libxml2-dev libglu1-mesa-dev

      - name: Resolve wine tag -> commit (peeled)
        id: pin
        run: |
          set -Eeuo pipefail
          TAG='${{ inputs.wine_tag }}'
          git ls-remote --tags https://github.com/ValveSoftware/wine.git "refs/tags/${TAG}^{}" > out.txt || true
          if [[ ! -s out.txt ]]; then
            git ls-remote --tags https://github.com/ValveSoftware/wine.git "refs/tags/${TAG}" > out.txt || true
          fi
          [[ -s out.txt ]] || { echo "Tag not found: ${TAG}" >&2; exit 1; }
          SHA=$(awk '{print $1}' out.txt)
          echo "wine_sha=$SHA" >> $GITHUB_OUTPUT
          echo "Pinned wine: $SHA"

      - name: Checkout Valve wine at pinned tag
        run: |
          git clone https://github.com/ValveSoftware/wine.git src-wine
          git -C src-wine fetch --depth=1 origin ${{ steps.pin.outputs.wine_sha }}
          git -C src-wine checkout ${{ steps.pin.outputs.wine_sha }}
          git -C src-wine log -1 --oneline

      - name: Bootstrap configure (autogen.sh)
        working-directory: src-wine
        run: |
          set -Eeuo pipefail
          ./autogen.sh
          test -x configure || { echo "autogen.sh did not produce ./configure" >&2; exit 1; }

      - name: Install elegant target shims for clang/clang++ (map arm64ec-windows -> arm64ec-w64-mingw32, robust)
        run: |
          set -Eeuo pipefail
          SHIMS_DIR="${GITHUB_WORKSPACE}/.shims"; mkdir -p "$SHIMS_DIR"

          # clang wrapper (no variable expansion at write-time; array-safe; avoids recursion)
          cat >"$SHIMS_DIR/clang" <<'SH'
          #!/usr/bin/env bash
          set -Eeuo pipefail
          self="$(readlink -f "$0" 2>/dev/null || echo "$0")"
          shim_dir="$(dirname "$self")"
          # pick the first clang in PATH that is not this shim
          real="$(type -ap clang | grep -v "^${shim_dir}/clang$" | head -n1)"
          if [[ -z "${real:-}" ]]; then
            real="$(command -v clang)"
          fi
          args=()
          prev_is_target=0
          for a in "$@"; do
            if [[ $prev_is_target -eq 1 ]]; then
              if [[ "$a" == "arm64ec-windows" ]]; then
                args+=("arm64ec-w64-mingw32")
              else
                args+=("$a")
              fi
              prev_is_target=0
              continue
            fi
            case "$a" in
              -target)
                args+=("$a"); prev_is_target=1 ;;
              -target=arm64ec-windows)
                args+=("--target=arm64ec-w64-mingw32") ;;
              *)
                args+=("$a") ;;
            esac
          done
          exec "$real" "${args[@]}"
          SH
          chmod +x "$SHIMS_DIR/clang"

          # clang++ wrapper (same logic)
          cat >"$SHIMS_DIR/clang++" <<'SH'
          #!/usr/bin/env bash
          set -Eeuo pipefail
          self="$(readlink -f "$0" 2>/dev/null || echo "$0")"
          shim_dir="$(dirname "$self")"
          real="$(type -ap clang++ | grep -v "^${shim_dir}/clang\+\+$" | head -n1)"
          if [[ -z "${real:-}" ]]; then
            real="$(command -v clang++)"
          fi
          args=()
          prev_is_target=0
          for a in "$@"; do
            if [[ $prev_is_target -eq 1 ]]; then
              if [[ "$a" == "arm64ec-windows" ]]; then
                args+=("arm64ec-w64-mingw32")
              else
                args+=("$a")
              fi
              prev_is_target=0
              continue
            fi
            case "$a" in
              -target)
                args+=("$a"); prev_is_target=1 ;;
              -target=arm64ec-windows)
                args+=("--target=arm64ec-w64-mingw32") ;;
              *)
                args+=("$a") ;;
            esac
          done
          exec "$real" "${args[@]}"
          SH
          chmod +x "$SHIMS_DIR/clang++"

          # Ensure shims precede toolchain bin
          echo "PATH=${SHIMS_DIR}:$PATH" >> $GITHUB_ENV

          # Smoke-test wrapper: plain clang must work; target mapping shouldn't crash the wrapper
          echo 'int main(void){return 0;}' > t.c
          clang -c t.c -o t.o
          clang -target arm64ec-windows -c t.c -o t2.o || true
          rm -f t.c t.o t2.o || true

      - name: Configure (ARM64EC + AArch64 + i386) with clang
        shell: bash
        working-directory: src-wine
        env:
          SHIM_DEBUG: "1"
          CONFIG_SHELL: /usr/bin/bash
          arm64ec_CC: ccache arm64ec-w64-mingw32-clang
          arm64ec_CXX: ccache arm64ec-w64-mingw32-clang++
          aarch64_CC: ccache aarch64-w64-mingw32-clang
          aarch64_CXX: ccache aarch64-w64-mingw32-clang++
          i386_CC: ccache i686-w64-mingw32-clang
          i386_CXX: ccache i686-w64-mingw32-clang++
          DLLTOOL: llvm-dlltool
          WINDRES: llvm-windres
          AR: llvm-ar
          RANLIB: llvm-ranlib
        run: |
          set -Eeuo pipefail
          echo ::group::tooling
          echo "PATH=$PATH"
          type -ap clang || true
          which arm64ec-w64-mingw32-clang || true
          which aarch64-w64-mingw32-clang || true
          which i686-w64-mingw32-clang || true
          echo ::endgroup::

          mkdir -p build && cd build

          # Run configure with trace and capture logs
          set +e
          bash -x ../configure \
            --enable-archs=arm64ec,aarch64,i386 \
            --with-mingw=clang \
            --disable-tests \
            --prefix="${PREFIX}" \
            2> configure.trace.txt | tee configure.stdout.txt
          st=$?
          set -e

          echo ::group::config.log highlights
          if [ -f config.log ]; then
            if ! grep -nE 'error:|cannot |failed ' config.log | sed -n '1,200p'; then
              tail -n 200 config.log || true
            fi
          else
            echo "config.log not generated"
          fi
          echo ::endgroup::

          echo ::group::configure.trace head
          sed -n '1,160p' configure.trace.txt || true
          echo ::endgroup::

          if [ $st -ne 0 ]; then
            echo "::error title=configure failed::See 'config.log' and 'configure.trace.txt' above"
            exit $st
          fi

      - name: Build & Install (ccache on)
        working-directory: src-wine/build
        run: |
          ccache -z || true
          make -j"$(nproc)"
          ccache -s || true
          make install
          mkdir -p "${STAGE}"
          rsync -a "${PREFIX}/" "${STAGE}/"
          rm -rf "${STAGE}/share/man" "${STAGE}/share/applications" \
                 "${STAGE}/share/icons" "${STAGE}/share/pixmaps" \
                 "${STAGE}/share/mime" || true

      - name: Verify required lib/wine triplets
        run: |
          set -Eeuo pipefail
          missing=0
          ST_PATH="${STAGE}"
          for d in aarch64-unix aarch64-windows i386-windows; do
            [[ -d "$ST_PATH/lib/wine/$d" ]] || { echo "::error title=Missing triplet::$d missing"; missing=1; }
          done
          [[ -f "$ST_PATH/share/wine/wine.inf" ]] || { echo "::error title=Missing wine.inf::share/wine/wine.inf missing"; missing=1; }

          echo ::group::bin
          [[ -d "$ST_PATH/bin" ]] && find "$ST_PATH/bin" -maxdepth 1 -type f -print0 | xargs -0 -r -n1 basename | sort || true
          echo ::endgroup::

          echo ::group::lib/wine
          [[ -d "$ST_PATH/lib/wine" ]] && find "$ST_PATH/lib/wine" -maxdepth 1 -mindepth 1 -type d -print0 | xargs -0 -r -n1 basename | sort || true
          echo ::endgroup::
          exit ${missing}

      - name: Pack runtime (tar.xz, multi-thread)
        run: tar -C "${STAGE}" -I 'xz -T0 -9' -cf wine-${{ inputs.wine_tag }}-arm64ec-wow64.tar.xz .

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: wine-${{ inputs.wine_tag }}-arm64ec-wow64
          path: wine-${{ inputs.wine_tag }}-arm64ec-wow64.tar.xz
          if-no-files-found: error
