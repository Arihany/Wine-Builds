on:
  workflow_dispatch:
    inputs:
      wine_tag:
        description: 'ValveSoftware/wine tag (e.g. proton-wine-10.0-2d)'
        required: true
        default: 'proton-wine-10.0-2d'
      toolchain_url:
        description: 'Override URL for llvm-mingw toolchain asset (Linux/Ubuntu tar.*). If empty, auto-select (prefers bylaws ubuntu-20.04 x86_64).'
        required: false
        default: ''

permissions:
  contents: read
  actions: read

concurrency:
  group: wine-${{ github.ref }}-${{ inputs.wine_tag }}
  cancel-in-progress: true

defaults:
  run:
    shell: 'bash --noprofile --norc -Eeuo pipefail {0}'

jobs:
  build:
    runs-on: ubuntu-24.04
    env:
      PREFIX: ${{ github.workspace }}/_inst
      STAGE:  ${{ github.workspace }}/_stage
      TOOLCHAIN_ROOT: ${{ github.workspace }}/.toolchains
      LLVM_TC_DIR: ${{ github.workspace }}/.toolchains/llvm-mingw-arm64ec
      CCACHE_DIR: ${{ github.workspace }}/.ccache
      CCACHE_MAXSIZE: 4G
      CCACHE_COMPRESS: '1'
      CCACHE_COMPILERCHECK: content
      CCACHE_BASEDIR: ${{ github.workspace }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Prepare dirs
        run: mkdir -p "$TOOLCHAIN_ROOT" "$CCACHE_DIR"

      - name: Query llvm-mingw meta (prefer bylaws ubuntu-20.04 x86_64)
        id: tcmeta
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -Eeuo pipefail
          # 0) Manual override
          override_url='${{ inputs.toolchain_url }}'
          if [[ -n "$override_url" ]]; then
            ov_file=$(basename "$override_url")
            ov_tag="$ov_file"
            ov_tag="${ov_tag%.tar.xz}"
            ov_tag="${ov_tag%.tar.zst}"
            ov_tag="${ov_tag%.tar.gz}"
            echo "Using override toolchain asset: $ov_file (tag=$ov_tag)"
            echo "tag=$ov_tag" >> "$GITHUB_OUTPUT"
            echo "url=$override_url" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # host arch pattern for generic fallback
          host=$(uname -m)
          case "$host" in
            x86_64|amd64) host_pat='(x86_64|amd64|x64)';;
            aarch64|arm64) host_pat='(aarch64|arm64)';;
            *) echo "Unsupported host arch: $host" >&2; exit 1;;
          esac

          per_page=50
          api="https://api.github.com/repos/bylaws/llvm-mingw/releases?per_page=${per_page}"
          tmp_json=$(mktemp)
          http=$(curl -fsS -H "Authorization: Bearer ${GH_TOKEN}" -H 'Accept: application/vnd.github+json' -o "$tmp_json" -w '%{http_code}' "$api")
          if [[ "$http" != 200 ]]; then
            echo "::error title=GitHub API error::HTTP $http from $api"; sed -n '1,160p' "$tmp_json" || true; exit 1
          fi

          jq_first_ubuntu2004=$(mktemp)
          cat >"$jq_first_ubuntu2004" <<'JQ'
            .[] | .tag_name as $tag | .assets[]? | select(
              (.name | test("(?i)llvm-mingw-.*-ubuntu-20[.]04-x86_64[.]tar[.](xz|zst|gz)$"))
            ) | [$tag, .browser_download_url] | @tsv
          JQ

          jq_generic=$(mktemp)
          cat >"$jq_generic" <<'JQ'
            .[] | .tag_name as $tag | .assets[]? | select(
              (.name | test("(?i)llvm-mingw-.*-(ubuntu|linux)-")) and
              (.name | test(env.HOST_PAT)) and
              (.name | test("[.]tar[.](xz|zst|gz)$"))
            ) | [$tag, .browser_download_url] | @tsv
          JQ

          HOST_PAT="$host_pat" jq -r -f "$jq_first_ubuntu2004" "$tmp_json" | head -n1 > match.txt || true
          if [[ ! -s match.txt ]]; then
            HOST_PAT="$host_pat" jq -r -f "$jq_generic" "$tmp_json" | head -n1 > match.txt || true
          fi
          if [[ ! -s match.txt ]]; then
            echo "::error title=No matching llvm-mingw Linux asset::Searched last ${per_page} releases; host=$host (${host_pat})"
            jq -r '.[0].assets[]?.name' "$tmp_json" | head -n20 || true
            exit 1
          fi

          tag=$(cut -f1 match.txt)
          url=$(cut -f2 match.txt)
          echo "tag=$tag" >> "$GITHUB_OUTPUT"
          echo "url=$url" >> "$GITHUB_OUTPUT"

      - name: Cache toolchain (extracted)
        id: cache_tc
        uses: actions/cache@v4
        with:
          path: ${{ env.LLVM_TC_DIR }}
          key: llvm-mingw-arm64ec-${{ runner.os }}-${{ steps.tcmeta.outputs.tag }}

      - name: Download & extract toolchain if cache missed
        if: steps.cache_tc.outputs.cache-hit != 'true'
        run: |
          set -Eeuo pipefail
          mkdir -p "$LLVM_TC_DIR"
          cd "$TOOLCHAIN_ROOT"
          file=$(basename "${{ steps.tcmeta.outputs.url }}")
          echo "Downloading: $file"
          curl -fL --retry 5 --retry-delay 3 -o "$file" "${{ steps.tcmeta.outputs.url }}"
          case "$file" in
            *.tar.xz)  tar -C "$LLVM_TC_DIR" --strip-components=1 -xf "$file" ;;
            *.tar.zst) tar --zstd -C "$LLVM_TC_DIR" --strip-components=1 -xf "$file" ;;
            *.tar.gz)  tar -C "$LLVM_TC_DIR" --strip-components=1 -xzf "$file" ;;
            *) echo "Unknown archive format: $file" >&2; exit 1 ;;
          esac

      - name: Add toolchain to PATH (prepend)
        run: echo "PATH=${{ env.LLVM_TC_DIR }}/bin:$PATH" >> $GITHUB_ENV

      - name: Sanity probe (gcc wrappers) and arm64ec link
        run: |
          set -Eeuo pipefail
          echo ::group::which
          which arm64ec-w64-mingw32-gcc || true
          which arm64ec-w64-mingw32-g++ || true
          which aarch64-w64-mingw32-gcc || true
          which i686-w64-mingw32-gcc || true
          echo ::endgroup::

          echo ::group::arm64ec-probe
          set +e
          printf 'int main(void){return 0;}' > t.c
          arm64ec-w64-mingw32-gcc -v t.c -o t.exe
          stat t.exe || true
          rm -f t.c t.exe || true
          echo ::endgroup::

      - name: Verify ARM64EC toolchain presence (fail-fast)
        run: |
          set -Eeuo pipefail
          need="arm64ec-w64-mingw32-gcc arm64ec-w64-mingw32-g++ aarch64-w64-mingw32-gcc aarch64-w64-mingw32-g++ i686-w64-mingw32-gcc i686-w64-mingw32-g++ llvm-dlltool llvm-windres lld-link"
          ok=1
          for b in $need; do
            if ! command -v "$b" >/dev/null 2>&1; then echo "::error title=Missing::$b not found"; ok=0; else which "$b"; "$b" --version | head -n1 || true; fi
          done
          # ARM64EC CRT + UCRT presence
          test -f "$LLVM_TC_DIR/arm64ec-w64-mingw32/lib/libucrt.a" || { echo '::error title=Missing UCRT import lib::libucrt.a not found for arm64ec'; ok=0; }
          test -f "$LLVM_TC_DIR/arm64ec-w64-mingw32/lib/crt2.o" || { echo '::error title=Missing CRT startup::crt2.o not found for arm64ec'; ok=0; }
          # os_arm64x thunks should be present in some archive
          sym_ok=0
          for a in "$LLVM_TC_DIR/arm64ec-w64-mingw32/lib"/*.a; do
            if llvm-nm -g --defined-only "$a" 2>/dev/null | grep -E "__os_arm64x_(check_icall|dispatch_call_no_redirect)" -q; then sym_ok=1; break; fi
          done
          if [[ $sym_ok -ne 1 ]]; then
            echo '::error title=ARM64EC thunks missing::__os_arm64x_* symbols not found in import/static libs'; ok=0
          fi
          if [[ $ok -ne 1 ]]; then
            echo "::error title=ARM64EC toolchain incomplete::Provide toolchain_url for an ARM64EC-capable llvm-mingw (ucrt) release"; exit 1
          fi

      - name: Cache ccache
        uses: actions/cache@v4
        with:
          path: ${{ env.CCACHE_DIR }}
          key: ccache-${{ runner.os }}-${{ inputs.wine_tag }}-${{ steps.tcmeta.outputs.tag }}-gccv1
          restore-keys: |
            ccache-${{ runner.os }}-

      - name: Install build deps (incl. Debian Wine control.in hints)
        run: |
          set -Eeuo pipefail
          sudo apt-get update -y -o Acquire::Retries=3
          sudo apt-get install -y --no-install-recommends \
            build-essential clang lld git curl jq xz-utils zstd rsync pkg-config \
            bison flex gettext autoconf automake libtool \
            libfreetype6-dev libfontconfig1-dev libglib2.0-dev libunwind-dev \
            libx11-dev libxext-dev libxi-dev libxrandr-dev libxrender-dev \
            libxcursor-dev libxfixes-dev libxinerama-dev libxcomposite-dev \
            libxdamage-dev libxkbcommon-dev libwayland-dev libdbus-1-dev \
            libasound2-dev libpulse-dev libudev-dev libvulkan-dev libopengl-dev \
            ocl-icd-opencl-dev zlib1g-dev libjpeg-dev libpng-dev libtiff-dev \
            libgsm1-dev libldap2-dev libpcap0.8-dev ccache \
            libgnutls28-dev liblcms2-dev libkrb5-dev libcups2-dev \
            libgphoto2-dev libsane-dev libmpg123-dev libsdl2-dev libopenal-dev \
            libosmesa6-dev libvkd3d-dev libgstreamer-plugins-base1.0-dev \
            libgstreamer1.0-dev libcapi20-dev libxslt1-dev libxml2-dev libglu1-mesa-dev \
            libgettextpo-dev

      - name: Resolve wine tag -> commit (peeled)
        id: pin
        run: |
          set -Eeuo pipefail
          TAG='${{ inputs.wine_tag }}'
          git ls-remote --tags https://github.com/ValveSoftware/wine.git "refs/tags/${TAG}^{}" > out.txt || true
          if [[ ! -s out.txt ]]; then
            git ls-remote --tags https://github.com/ValveSoftware/wine.git "refs/tags/${TAG}" > out.txt || true
          fi
          [[ -s out.txt ]] || { echo "Tag not found: ${TAG}" >&2; exit 1; }
          SHA=$(awk '{print $1}' out.txt)
          echo "wine_sha=$SHA" >> $GITHUB_OUTPUT
          echo "Pinned wine: $SHA"

      - name: Checkout Valve wine at pinned tag
        run: |
          git clone https://github.com/ValveSoftware/wine.git src-wine
          git -C src-wine fetch --depth=1 origin ${{ steps.pin.outputs.wine_sha }}
          git -C src-wine checkout ${{ steps.pin.outputs.wine_sha }}
          git -C src-wine log -1 --oneline

      - name: Bootstrap configure (autogen.sh)
        working-directory: src-wine
        run: |
          set -Eeuo pipefail
          ./autogen.sh
          test -x configure || { echo "autogen.sh did not produce ./configure" >&2; exit 1; }

      - name: Configure (ARM64EC + AArch64 + i386) using gcc wrappers
        shell: bash
        working-directory: src-wine
        env:
          CONFIG_SHELL: /usr/bin/bash
          arm64ec_CC: ccache arm64ec-w64-mingw32-gcc
          arm64ec_CXX: ccache arm64ec-w64-mingw32-g++
          arm64ec_CPPFLAGS: -D_WIN32_WINNT=0x0A00 -DWINVER=0x0A00
          arm64ec_CFLAGS: -U__x86_64__ -U_M_X64 -U_M_AMD64 -D__arm64ec__ -D__ARM64EC__ -D_M_ARM64EC=1 -D__aarch64__ -D_M_ARM64=1 -Wno-pragma-pack -fno-strict-aliasing -ffunction-sections -gdwarf-4
          arm64ec_CXXFLAGS: -U__x86_64__ -U_M_X64 -U_M_AMD64 -D__arm64ec__ -D__ARM64EC__ -D_M_ARM64EC=1 -D__aarch64__ -D_M_ARM64=1 -Wno-pragma-pack -fno-strict-aliasing -ffunction-sections -gdwarf-4
          aarch64_CC: ccache aarch64-w64-mingw32-gcc
          aarch64_CXX: ccache aarch64-w64-mingw32-g++
          i386_CC: ccache i686-w64-mingw32-gcc
          i386_CXX: ccache i686-w64-mingw32-g++
          DLLTOOL: llvm-dlltool
          WINDRES: llvm-windres
          AR: llvm-ar
          RANLIB: llvm-ranlib
        run: |
          set -Eeuo pipefail
          mkdir -p build && cd build

          set +e
          bash -x ../configure \
            --enable-archs=arm64ec,aarch64,i386 \
            --with-mingw=gcc \
            --disable-tests \
            --prefix="${PREFIX}" \
            2> configure.trace.txt | tee configure.stdout.txt
          st=$?
          set -e

          echo ::group::config.log highlights
          if [ -f config.log ]; then
            if ! grep -nE 'error:|cannot |failed ' config.log | sed -n '1,200p'; then
              tail -n 200 config.log || true
            fi
          else
            echo "config.log not generated"
          fi
          echo ::endgroup::

          echo ::group::configure.trace head
          sed -n '1,160p' configure.trace.txt || true
          echo ::endgroup::

          if [ $st -ne 0 ]; then
            echo "::error title=configure failed::See 'config.log' and 'configure.trace.txt' above"
            exit $st
          fi

      - name: Build & Install (ccache on)
        working-directory: src-wine/build
        run: |
          ccache -z || true
          make -j"$(nproc)"
          ccache -s || true
          make install
          mkdir -p "${STAGE}"
          rsync -a "${PREFIX}/" "${STAGE}/"
          rm -rf "${STAGE}/share/man" "${STAGE}/share/applications" \
                 "${STAGE}/share/icons" "${STAGE}/share/pixmaps" \
                 "${STAGE}/share/mime" || true

      - name: Verify required lib/wine triplets
        run: |
          set -Eeuo pipefail
          missing=0
          ST_PATH="${STAGE}"
          for d in aarch64-unix aarch64-windows i386-windows; do
            [[ -d "$ST_PATH/lib/wine/$d" ]] || { echo "::error title=Missing triplet::$d missing"; missing=1; }
          done
          [[ -f "$ST_PATH/share/wine/wine.inf" ]] || { echo "::error title=Missing wine.inf::share/wine/wine.inf missing"; missing=1; }

          echo ::group::bin
          [[ -d "$ST_PATH/bin" ]] && find "$ST_PATH/bin" -maxdepth 1 -type f -print0 | xargs -0 -r -n1 basename | sort || true
          echo ::endgroup::

          echo ::group::lib/wine
          [[ -d "$ST_PATH/lib/wine" ]] && find "$ST_PATH/lib/wine" -maxdepth 1 -mindepth 1 -type d -print0 | xargs -0 -r -n1 basename | sort || true
          echo ::endgroup::
          exit ${missing}

      - name: Pack runtime (tar.xz, multi-thread)
        run: tar -C "${STAGE}" -I 'xz -T0 -9' -cf wine-${{ inputs.wine_tag }}-arm64ec-wow64.tar.xz .

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: wine-${{ inputs.wine_tag }}-arm64ec-wow64
          path: wine-${{ inputs.wine_tag }}-arm64ec-wow64.tar.xz
          if-no-files-found: error
